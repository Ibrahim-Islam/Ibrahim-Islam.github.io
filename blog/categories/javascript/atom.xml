<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | ]]></title>
  <link href="http://ibrahim-islam.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://ibrahim-islam.github.io/"/>
  <updated>2016-01-31T20:39:25+06:00</updated>
  <id>http://ibrahim-islam.github.io/</id>
  <author>
    <name><![CDATA[Ibrahim Islam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Closures In Javascript]]></title>
    <link href="http://ibrahim-islam.github.io/blog/2016/01/30/closures-in-javascript/"/>
    <updated>2016-01-30T14:55:33+06:00</updated>
    <id>http://ibrahim-islam.github.io/blog/2016/01/30/closures-in-javascript</id>
    <content type="html"><![CDATA[<p>A Closure in its simplest term is an <em>Inner Function</em> (function within a function) that has access to its variables and the Outer Function&rsquo;s variables. Closures (the inner function) will still have access to the outer function&rsquo;s variables even when the outer function returns. So, we can store the inner function in a variable and execute it later in time and still have access to the outer function&rsquo;s variables. <strong>Closure do not actually hold the outer function&rsquo;s variables instead it holds the references.</strong> So, if the outer function&rsquo;s variable&rsquo;s values changes so will values for the Closure when it executes.</p>

<!-- More -->


<p>The following is an example where Closure is used to demonstrate using Properties in Javascript e.g. making use of Private variable, getter and setter as Closures:</p>

<pre><code class="js">function celebrityID() {
    var celebrityID = 999;
    return {
        getID: function () {
            return celebrityID;
        },
        setID: function (theNewID) {
            celebrityID = theNewID;
        }
    };
}

var mjID = celebrityID();//Returns the object inside
mjID.getID(); //999
mjID.setID(567); 
alert(mjID.getID()); //567
</code></pre>

<p>But the fact that outer function variables are stored as references in Closures also arises problems like in a for loop in Javascript with Closures depicted in the following code:</p>

<pre><code class="js">function celebrityIDCreator(theCelebrities) {
    var uniqueID = 100;
    for (i = 0; i &lt; theCelebrities.length; i++) {
        theCelebrities[i].id = function () {
            return uniqueID + i;
        };
    }
    return theCelebrities;
}

var actionCelebs = [{
    name: "Stallone",
    id: 0
}, {
    name: "Cruise",
    id: 0
}, {
    name: "Willis",
    id: 0
}];

var createIdForActionCelebs = celebrityIDCreator(actionCelebs);
var stalloneID = createIdForActionCelebs[0];
alert(stalloneID.id());
</code></pre>

<p>So, what we are trying to do in above code is to pass in an array of objects to a function where its property will be modified and then we get to output the modified property. In the <code>celebrityIDCreator()</code> function we are running a for loop and assigning a function to the array of objects passed and then returning the modified array. According to the logic we will expect the output alerted to be <em>100</em> but it will appear to be <em>103</em>. Because when the function in <code>id</code> is invoked it will execute exactly then and by then the for loop had executed and <code>i</code> had been modified and incremented to <em>3</em> so the returning value from the Closure would be <em>103</em>.</p>

<blockquote><p>As a side note, Javascript is not <em>Block Scope</em> so the <code>i</code> counter initialized can be accessed from anywhere within the function and that is why it is <em>Function Scoped</em> instead.</p></blockquote>

<p>So, what can we do to achieve what we want to do above correctly? One option is to execute the <em>anonymous function</em> here (Closure) then and there inside the for loop as the counter progresses and return only the modified id instead of assigning a function which needs to be executed thus, not repeating the error again. To do that we code the following:</p>

<pre><code class="js">function celebrityIDCreator(theCelebrities) {
    var uniqueID = 100;
    for (i = 0; i &lt; theCelebrities.length; i++) {
        theCelebrities[i].id = function () {
            return uniqueID + i;
        }(); //'()' will execute the function then and there
    }
    return theCelebrities;
}

var actionCelebs = [{
    name: "Stallone",
    id: 0
}, {
    name: "Cruise",
    id: 0
}, {
    name: "Willis",
    id: 0
}];

var createIdForActionCelebs = celebrityIDCreator(actionCelebs);

var stalloneID = createIdForActionCelebs[0];
alert(stalloneID.id); // 100

var cruiseID = createIdForActionCelebs[1];
alert(cruiseID.id); // 101

var willisID = createIdForActionCelebs[2];
alert(willisID.id); // 102
</code></pre>

<p>I scoured the net before understanding Closure. So, do not hate me if you have seen something here before :P</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hoisting In Javascript]]></title>
    <link href="http://ibrahim-islam.github.io/blog/2016/01/28/hoisting-in-javascript/"/>
    <updated>2016-01-28T00:59:52+06:00</updated>
    <id>http://ibrahim-islam.github.io/blog/2016/01/28/hoisting-in-javascript</id>
    <content type="html"><![CDATA[<p>A rather unknown topic of Javascript is <strong>Hoisting</strong>. The Javascript compiler does not execute code as we write it. Hoisting is its way of re-arranging our code before executing it which is making declerations and taking it to the top of current scope. So, below code snippet:</p>

<!-- More -->


<pre><code class="js">function SumSquare(a, b) {
    var x = add(a * a, b * b);
    return x;

    function add(c, d) {
        var a = c + d;
        return a;
    }
}
</code></pre>

<p>Interpreted as:</p>

<pre><code class="js">function SumSquare(a, b) {
    var x = undefined;

    function add(c, d) {
        var a = c + d;
        return a;
    }

    x = add(a * a, b * b);
    return x;
}
</code></pre>

<p>As we can see, JS did the following:</p>

<ul>
<li>Declared variables</li>
<li>Hoisted declerations to the top of current scope</li>
<li>Hoisted declared/named functions to the top</li>
</ul>


<p>But same cannot be said for <em>function assignments</em> :</p>

<pre><code class="js">function Random() {
    var random = function(){
        return 10;
    };

    return random;

    var random = function (){
        return 9;
    };
}
</code></pre>

<p>Will become:</p>

<pre><code class="js">function Random() {
    var random = undefined; //will be overwritten by 2nd random
    var random = undefined;

    var random = function(){
        return 10;
    };

    return random;

    //unreachable
    var random = function (){
        return 9;
    };
}
</code></pre>

<p>This is what happened:</p>

<ul>
<li>Function assignments did not get hoisted because assignments are not hoisted</li>
<li>Variables with same identifier gets overwritten by the last one</li>
<li>Second <code>random</code> function will not be reached because of <code>return</code></li>
</ul>


<p>Lets go through another complex one for fun:</p>

<pre><code class="js">function theBridgeOfHoistingDoom() {
    function fellowship() {
        return "friends";
    }
    var sword = "sting";
    var dwarf = function () {
        return "axe";
    };
    var fall = "Fly you fools!";
    fellowship = function () {
        return "broken";
    };
    ring();
    return sword;
    fellowship = function () {
        return "mines"
    };
    sword = function () {
        return "glamdring";
    };
    var ring = function () {
        return "precious";
    };
}   
</code></pre>

<p>Will become:</p>

<pre><code class="js">function theBridgeOfHoistingDoom() {
    var sword = undefined;
    var dwarf = undefined;
    var fall = undefined;
    var ring = undefined;

    function fellowship(){
        return "friends";
    }
    sword = "sting";
    dwarf = function () {
        return "axe";
    };
    fall = "Fly you fools!";
    fellowship = function () {
        return "broken";
    };

    ring();
    return sword;

    //unreachable
    fellowship = function () {
        return "mines"
    };
    sword = function () {
        return "glamdring";
    };
    ring = function () {
        return "precious";
    };
}
</code></pre>

<p>Things happened above:</p>

<ul>
<li>Variable declerations</li>
<li>Variables hoisted</li>
<li>No decleration for <code>fellowship</code> because it was a already named/declared function so it will just be overwritten/re-assigned.</li>
</ul>


<hr />

<p>Due to the reasons how javascript hoisting works, we should always declare variables at the top of its scope to prevent getting unexpected results and in addition to that always use <code>"use strict;"</code> on all our scripts (.js) to enforce more checks.</p>

<p>This was my learning when I went through <a href="www.codeschool.com">CodeSchool</a> Javascript course followed by some additional reading online.</p>
]]></content>
  </entry>
  
</feed>
