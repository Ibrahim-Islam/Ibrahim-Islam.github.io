<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ef | ]]></title>
  <link href="http://ibrahim-islam.github.io/blog/categories/ef/atom.xml" rel="self"/>
  <link href="http://ibrahim-islam.github.io/"/>
  <updated>2016-01-31T23:36:37+06:00</updated>
  <id>http://ibrahim-islam.github.io/</id>
  <author>
    <name><![CDATA[Ibrahim Islam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EF : Alternative way of handling Many-To-Many relationships]]></title>
    <link href="http://ibrahim-islam.github.io/blog/2016/01/31/ef-alternative-way-of-handling-many-to-many-relationships/"/>
    <updated>2016-01-31T22:18:27+06:00</updated>
    <id>http://ibrahim-islam.github.io/blog/2016/01/31/ef-alternative-way-of-handling-many-to-many-relationships</id>
    <content type="html"><![CDATA[<p>Handling many-to-many relationships using Entity Framework with Code-First approach has been a little challanging for me in the past. I do not recall properly but most was due to having CRUD operations on the child collection objects. Also, due to EF abstraction in the Core-First approach, handling data directly in the database in a traditional way becomes a bit difficult.</p>

<!-- More -->


<p>Follwing is the usual way to model many-to-many relations with Code-First approach in EF:</p>

<pre><code class="csharp">public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public virtual ICollection&lt;Qualification&gt; Qualifications { get; set; }
}

public class Qualification
{
    public int Id { get; set; }
    public string Title { get; set; }
    public virtual ICollection&lt;Employee&gt; Employees { get; set; }
}
</code></pre>

<p>Now, operations on these might look like following:</p>

<pre><code class="csharp">//Adding a qualification to an employee
var emp = await db.Employees.SingleOrDefaultAsync(p =&gt; p.Id == 4);
var qual = await db.Qualifications.SingleOrDefaultAsync(p =&gt; p.Id == 4);
emp.Qualifications.Add(qual);
</code></pre>

<p>Assuming, I am getting the entities Ids from the client, I need to pull them everytime and make changes accordingly. This is abstraction done well by EF.</p>

<p>But if I want more direct access I can break the relationship into 1-to-many:</p>

<pre><code class="csharp">public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public virtual ICollection&lt;EmployeesQualifications&gt; EmployeeQualifications { get; set; }
}

public class EmployeesQualifications
{
    public int Id { get; set; }
    public int EmployeeId { get; set; }
    public int QualificationId { get; set; }
}

public class Qualification
{
    public int Id { get; set; }
    public string Title { get; set; }
    public virtual ICollection&lt;EmployeesQualifications&gt; QualificationEmployees { get; set; }
}
</code></pre>

<p>And now I can perform operations like following given I am getting only the entities' Ids:</p>

<pre><code class="csharp">//Adding a qualification to an employee
db.EmployeesQualifications.Add(new EmployeesQualifications
{
    EmployeeId = 4,
    QualificationId = 4
});
</code></pre>

<p>By using this approach, I have more direct access to the tables and I reduce the code I need to bring in related entities into the context to perfrom an operation. Its nothing ground breaking but I think its worth putting it out there for people to know and for me to remind myself in the future.</p>
]]></content>
  </entry>
  
</feed>
