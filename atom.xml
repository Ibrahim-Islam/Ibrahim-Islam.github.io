<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[]]></title>
  <link href="http://ibrahim-islam.github.io/atom.xml" rel="self"/>
  <link href="http://ibrahim-islam.github.io/"/>
  <updated>2016-01-31T23:36:37+06:00</updated>
  <id>http://ibrahim-islam.github.io/</id>
  <author>
    <name><![CDATA[Ibrahim Islam]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[EF : Alternative way of handling Many-To-Many relationships]]></title>
    <link href="http://ibrahim-islam.github.io/blog/2016/01/31/ef-alternative-way-of-handling-many-to-many-relationships/"/>
    <updated>2016-01-31T22:18:27+06:00</updated>
    <id>http://ibrahim-islam.github.io/blog/2016/01/31/ef-alternative-way-of-handling-many-to-many-relationships</id>
    <content type="html"><![CDATA[<p>Handling many-to-many relationships using Entity Framework with Code-First approach has been a little challanging for me in the past. I do not recall properly but most was due to having CRUD operations on the child collection objects. Also, due to EF abstraction in the Core-First approach, handling data directly in the database in a traditional way becomes a bit difficult.</p>

<!-- More -->


<p>Follwing is the usual way to model many-to-many relations with Code-First approach in EF:</p>

<pre><code class="csharp">public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public virtual ICollection&lt;Qualification&gt; Qualifications { get; set; }
}

public class Qualification
{
    public int Id { get; set; }
    public string Title { get; set; }
    public virtual ICollection&lt;Employee&gt; Employees { get; set; }
}
</code></pre>

<p>Now, operations on these might look like following:</p>

<pre><code class="csharp">//Adding a qualification to an employee
var emp = await db.Employees.SingleOrDefaultAsync(p =&gt; p.Id == 4);
var qual = await db.Qualifications.SingleOrDefaultAsync(p =&gt; p.Id == 4);
emp.Qualifications.Add(qual);
</code></pre>

<p>Assuming, I am getting the entities Ids from the client, I need to pull them everytime and make changes accordingly. This is abstraction done well by EF.</p>

<p>But if I want more direct access I can break the relationship into 1-to-many:</p>

<pre><code class="csharp">public class Employee
{
    public int Id { get; set; }
    public string Name { get; set; }
    public virtual ICollection&lt;EmployeesQualifications&gt; EmployeeQualifications { get; set; }
}

public class EmployeesQualifications
{
    public int Id { get; set; }
    public int EmployeeId { get; set; }
    public int QualificationId { get; set; }
}

public class Qualification
{
    public int Id { get; set; }
    public string Title { get; set; }
    public virtual ICollection&lt;EmployeesQualifications&gt; QualificationEmployees { get; set; }
}
</code></pre>

<p>And now I can perform operations like following given I am getting only the entities' Ids:</p>

<pre><code class="csharp">//Adding a qualification to an employee
db.EmployeesQualifications.Add(new EmployeesQualifications
{
    EmployeeId = 4,
    QualificationId = 4
});
</code></pre>

<p>By using this approach, I have more direct access to the tables and I reduce the code I need to bring in related entities into the context to perfrom an operation. Its nothing ground breaking but I think its worth putting it out there for people to know and for me to remind myself in the future.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Closures In Javascript]]></title>
    <link href="http://ibrahim-islam.github.io/blog/2016/01/30/closures-in-javascript/"/>
    <updated>2016-01-30T14:55:33+06:00</updated>
    <id>http://ibrahim-islam.github.io/blog/2016/01/30/closures-in-javascript</id>
    <content type="html"><![CDATA[<p>A Closure in its simplest term is an <em>Inner Function</em> (function within a function) that has access to its variables and the Outer Function&rsquo;s variables. Closures (the inner function) will still have access to the outer function&rsquo;s variables even when the outer function returns. So, we can store the inner function in a variable and execute it later in time and still have access to the outer function&rsquo;s variables. <strong>Closure do not actually hold the outer function&rsquo;s variables instead it holds the references.</strong> So, if the outer function&rsquo;s variable&rsquo;s values changes so will values for the Closure when it executes.</p>

<!-- More -->


<p>The following is an example where Closure is used to demonstrate using Properties in Javascript e.g. making use of Private variable, getter and setter as Closures:</p>

<pre><code class="js">function celebrityID() {
    var celebrityID = 999;
    return {
        getID: function () {
            return celebrityID;
        },
        setID: function (theNewID) {
            celebrityID = theNewID;
        }
    };
}

var mjID = celebrityID();//Returns the object inside
mjID.getID(); //999
mjID.setID(567); 
alert(mjID.getID()); //567
</code></pre>

<p>But the fact that outer function variables are stored as references in Closures also arises problems like in a for loop in Javascript with Closures depicted in the following code:</p>

<pre><code class="js">function celebrityIDCreator(theCelebrities) {
    var uniqueID = 100;
    for (i = 0; i &lt; theCelebrities.length; i++) {
        theCelebrities[i].id = function () {
            return uniqueID + i;
        };
    }
    return theCelebrities;
}

var actionCelebs = [{
    name: "Stallone",
    id: 0
}, {
    name: "Cruise",
    id: 0
}, {
    name: "Willis",
    id: 0
}];

var createIdForActionCelebs = celebrityIDCreator(actionCelebs);
var stalloneID = createIdForActionCelebs[0];
alert(stalloneID.id());
</code></pre>

<p>So, what we are trying to do in above code is to pass in an array of objects to a function where its property will be modified and then we get to output the modified property. In the <code>celebrityIDCreator()</code> function we are running a for loop and assigning a function to the array of objects passed and then returning the modified array. According to the logic we will expect the output alerted to be <em>100</em> but it will appear to be <em>103</em>. Because when the function in <code>id</code> is invoked it will execute exactly then and by then the for loop had executed and <code>i</code> had been modified and incremented to <em>3</em> so the returning value from the Closure would be <em>103</em>.</p>

<blockquote><p>As a side note, Javascript is not <em>Block Scope</em> so the <code>i</code> counter initialized can be accessed from anywhere within the function and that is why it is <em>Function Scoped</em> instead.</p></blockquote>

<p>So, what can we do to achieve what we want to do above correctly? One option is to execute the <em>anonymous function</em> here (Closure) then and there inside the for loop as the counter progresses and return only the modified id instead of assigning a function which needs to be executed thus, not repeating the error again. To do that we code the following:</p>

<pre><code class="js">function celebrityIDCreator(theCelebrities) {
    var uniqueID = 100;
    for (i = 0; i &lt; theCelebrities.length; i++) {
        theCelebrities[i].id = function () {
            return uniqueID + i;
        }(); //'()' will execute the function then and there
    }
    return theCelebrities;
}

var actionCelebs = [{
    name: "Stallone",
    id: 0
}, {
    name: "Cruise",
    id: 0
}, {
    name: "Willis",
    id: 0
}];

var createIdForActionCelebs = celebrityIDCreator(actionCelebs);

var stalloneID = createIdForActionCelebs[0];
alert(stalloneID.id); // 100

var cruiseID = createIdForActionCelebs[1];
alert(cruiseID.id); // 101

var willisID = createIdForActionCelebs[2];
alert(willisID.id); // 102
</code></pre>

<p>I scoured the net before understanding Closure. So, do not hate me if you have seen something here before :P</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cross-Domain With WebAPI]]></title>
    <link href="http://ibrahim-islam.github.io/blog/2016/01/30/cross-domain-with-webapi/"/>
    <updated>2016-01-30T14:22:18+06:00</updated>
    <id>http://ibrahim-islam.github.io/blog/2016/01/30/cross-domain-with-webapi</id>
    <content type="html"><![CDATA[<p>Someday, there will rise a need to develop APIs that can be comsumed by multiple clients i.e. <strong>cross-domain</strong> requests; for example, APIs to be consumed by browser-based client applications e.g. Chrome Extension or an Angular app.</p>

<!-- More -->


<p>What is <strong>Cross-Domain</strong>?</p>

<blockquote><p>Cross-Domain HTTP requests are HTTP requests for resources from a different domain than the domain of the resource making the request. <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS">[1]</a></p></blockquote>

<p>and this is a big deal because <strong>cross-domain</strong> requests are subjected to a browsers' <strong>same-origin</strong> policy:</p>

<blockquote><p>The same-origin policy means that your JavaScript can only make AJAX calls back to the same origin of the containing Web page (where “origin” is defined as the combination of host name, protocol and port number). <a href="http://msdn.microsoft.com/en-us/magazine/dn532203.aspx">[2]</a></p></blockquote>

<p>Then there was <strong>CORS</strong>:</p>

<blockquote><p>Cross-origin resource sharing (CORS) is a World Wide Web Consortium (W3C) specification that lets JavaScript overcome the same-origin policy security restriction imposed by browsers.</p></blockquote>

<p>So, now what happens is that when a browser sees that a cross-domain request is about to happen it will send in additional headers (depending on the type of CORS request) with the request for the server to determine whether the requesting origin has access to it. There are 2 kinds of CORS request: <strong>Simple</strong> and <strong>Preflight</strong>.</p>

<h3>Simple CORS Request</h3>

<p>Simple CORS request are when the browser just adds an <code>origin</code> header with the request to identify the requester. If the browser sends a response with the header <code>Allow-Control-Allow-Origin</code> and its value set as <em>*</em> (meaning any origin) or at least the origin value that was sent with the request then it is successful and the requesting data will be present else error.
To summarise following conditions are to be met for a request for a simple cors request:</p>

<ul>
<li><code>GET</code>, <code>HEAD</code> or <code>POST</code></li>
<li>POST&rsquo;s <code>Content-Type</code> set as one of <code>application/x-www-form-urlencoded</code>, <code>multipart/form-data</code>, or <code>text/plain</code></li>
<li>No custom headers</li>
</ul>


<h3>Preflight CORS Request</h3>

<p>Applicable when conditions for a Simple CORS request are not met. Preflight CORS requests consist of an additional prior request using <code>OPTIONS</code> method to the server to get access permission before the actual request takes place. So, 2 requests per cross-domain request or each URL.</p>

<h3>Microsoft.AspNet.WebApi.Cors</h3>

<p>As you might have guessed from the sub-title above, it is a CORS framework for WebAPI widely available through <a href="https://www.nuget.org/packages/Microsoft.AspNet.WebApi.Cors">NuGet</a> to be referenced in your WebAPI application. It is as easy as enabling it on your <code>WebApiConfig.cs</code> file:</p>

<pre><code class="csharp">public static class WebApiConfig
{
  public static void Register(HttpConfiguration config)
  {
    // Enable Cors
    config.EnableCors();

    //...Routes
  }
}
</code></pre>

<p>Then decorate whatever controller which you want Cors support like below with whatever config you prefer. The following allows cors for all origins, headers and methods:</p>

<pre><code class="csharp">[EnableCors(origins: "*", headers: "*", methods: "*")]
public class TestController : ApiController 
{
    [HttpPost]
    public HttpResponseMessage Post()
    { }
}
</code></pre>

<p>More info can be found <a href="http://www.asp.net/web-api/overview/security/enabling-cross-origin-requests-in-web-api">here</a> on how to fully use this tool.</p>

<p>So, you have no worries about making your APIs cross-domain compliant now and have more control over accessibility. But few things to watch out like when making a <code>PUT</code> or <code>DELETE</code> request which is eligible for a Preflight CORS request and uses <code>OPTIONS</code> method (recall from earlier), you might have your controller set to accept only obvious HTTP methods like <code>POST</code> or <code>GET</code> which will fail the request because you had not allowed <code>OPTIONS</code> to get through.</p>

<p>This post is a summary of my learnings when I was stuck with handling cross-domain request (Preflight) in WebAPI. Hope it will help someone and comment below for any help.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hoisting In Javascript]]></title>
    <link href="http://ibrahim-islam.github.io/blog/2016/01/28/hoisting-in-javascript/"/>
    <updated>2016-01-28T00:59:52+06:00</updated>
    <id>http://ibrahim-islam.github.io/blog/2016/01/28/hoisting-in-javascript</id>
    <content type="html"><![CDATA[<p>A rather unknown topic of Javascript is <strong>Hoisting</strong>. The Javascript compiler does not execute code as we write it. Hoisting is its way of re-arranging our code before executing it which is making declerations and taking it to the top of current scope. So, below code snippet:</p>

<!-- More -->


<pre><code class="js">function SumSquare(a, b) {
    var x = add(a * a, b * b);
    return x;

    function add(c, d) {
        var a = c + d;
        return a;
    }
}
</code></pre>

<p>Interpreted as:</p>

<pre><code class="js">function SumSquare(a, b) {
    var x = undefined;

    function add(c, d) {
        var a = c + d;
        return a;
    }

    x = add(a * a, b * b);
    return x;
}
</code></pre>

<p>As we can see, JS did the following:</p>

<ul>
<li>Declared variables</li>
<li>Hoisted declerations to the top of current scope</li>
<li>Hoisted declared/named functions to the top</li>
</ul>


<p>But same cannot be said for <em>function assignments</em> :</p>

<pre><code class="js">function Random() {
    var random = function(){
        return 10;
    };

    return random;

    var random = function (){
        return 9;
    };
}
</code></pre>

<p>Will become:</p>

<pre><code class="js">function Random() {
    var random = undefined; //will be overwritten by 2nd random
    var random = undefined;

    var random = function(){
        return 10;
    };

    return random;

    //unreachable
    var random = function (){
        return 9;
    };
}
</code></pre>

<p>This is what happened:</p>

<ul>
<li>Function assignments did not get hoisted because assignments are not hoisted</li>
<li>Variables with same identifier gets overwritten by the last one</li>
<li>Second <code>random</code> function will not be reached because of <code>return</code></li>
</ul>


<p>Lets go through another complex one for fun:</p>

<pre><code class="js">function theBridgeOfHoistingDoom() {
    function fellowship() {
        return "friends";
    }
    var sword = "sting";
    var dwarf = function () {
        return "axe";
    };
    var fall = "Fly you fools!";
    fellowship = function () {
        return "broken";
    };
    ring();
    return sword;
    fellowship = function () {
        return "mines"
    };
    sword = function () {
        return "glamdring";
    };
    var ring = function () {
        return "precious";
    };
}   
</code></pre>

<p>Will become:</p>

<pre><code class="js">function theBridgeOfHoistingDoom() {
    var sword = undefined;
    var dwarf = undefined;
    var fall = undefined;
    var ring = undefined;

    function fellowship(){
        return "friends";
    }
    sword = "sting";
    dwarf = function () {
        return "axe";
    };
    fall = "Fly you fools!";
    fellowship = function () {
        return "broken";
    };

    ring();
    return sword;

    //unreachable
    fellowship = function () {
        return "mines"
    };
    sword = function () {
        return "glamdring";
    };
    ring = function () {
        return "precious";
    };
}
</code></pre>

<p>Things happened above:</p>

<ul>
<li>Variable declerations</li>
<li>Variables hoisted</li>
<li>No decleration for <code>fellowship</code> because it was a already named/declared function so it will just be overwritten/re-assigned.</li>
</ul>


<hr />

<p>Due to the reasons how javascript hoisting works, we should always declare variables at the top of its scope to prevent getting unexpected results and in addition to that always use <code>"use strict;"</code> on all our scripts (.js) to enforce more checks.</p>

<p>This was my learning when I went through <a href="www.codeschool.com">CodeSchool</a> Javascript course followed by some additional reading online.</p>
]]></content>
  </entry>
  
</feed>
